---
output:
  ioslides_presentation:
    incremental: true
    widescreen: true
    fullscreen: true
  pdf_document: default
  md_document: default
---

# Data Analysis in R

Adam Rawles


## Recap


- What is R and RStudio?
- Basic arithmetic operators
- Variable assigment
- Data types
- Data structures (including subsetting)
- Functions

## Overview


- Installing packages
- Loading data
- Cleaning data
- Summary statistics
- Graphs and plots


## Installing packages

- Installing packages with RStudio is easy to do
- RStudio has a built-in interface for installing packages...
- Or, you can use the R function `install.packages()`, and provide the name of the package(s) you want to install to the function

```{r installing_packages, eval = FALSE}
install.packages("ggplot2")
install.packages(c("ggplot2", "dplyr"))
```


- Packages must be loaded before they are available, via the `library()` function

```{r load_packages, eval = FALSE}
library(ggplot2)
```

- Note: if you close RStudio, you'll need to reload your packages

## Using packages

- If you've loaded a pacakge via `library()`, then you don't need to do anything else before you use it.
- However, then using a non-base R function, it's always a good idea to make it explicit what package it came from.
- We do that using `::`

```{r, eval = FALSE}
ggplot2::ggplot()
```
- This will mean that anyone reading your code will know exactly what package a function came from
- It'll also ensure that you're using the function you mean to in the event that two packages have functions with the same name

## Loading data


- Data can be loaded into R in many formats
- The easiest of which are .xlsx or .csv files
- These can be loaded into R two different ways
    - The first is by using the `read.csv()`/`read.xlsx()` functions
        - The read.csv() function takes a string of the file's path as it's only required input argument
            - But there are a number of optional arguments (e.g. header, stringsAsFactor,...)
        - The read.xlsx() function requires both a path, and the index of the sheet you want from the workbook
        
        
## Loading data


- The second is to use RStudio's built in "Import Dataset" interface
    - This interface essentially just acts as a wrapper to the `read.csv()/xlsx()` functions

## Loading data - example


<div align="center">
<img src="data_excel.png">
</div>

## Loading data - example


```{r loading_data_example, echo = TRUE}
consdata <- read.csv("consdata.csv", header = TRUE, stringsAsFactors = TRUE)

head(consdata, n = 2)

```


## Loading data - exercise


- Using RStudio's "Import Dataset" or the `read.csv()` function, load the cons_data dataset

## Data cleaning

- After the data is loaded into R, we need to make sure that each column is in the correct format (e.g. character, factor, numeric, etc.)
- This can be done two different ways:
    - You can either click on the dataframe in the Environment pane, which will open the dataframe in the Source pane
        - From here, you can hover over the column headers to see what type the data is stored as
    - Or, you can use the is.xxxxx functions to check from the console.
        - To do this, you choose the appropriate function for the type you want (e.g. `is.numeric()`), and include the column you want to check as an argument
        
## Data cleaning

```{r data_cleaning_1, echo = TRUE}

is.numeric(consdata$meter_reading) ## we could also do is.numeric(consdata[,1]) as per our last session on subsetting

is.numeric(consdata$actual_estimate)

is.factor(consdata$actual_estimate)

```

## Data cleaning


- If you want to get the type of a column without comparing it to other types, you use the is() function
- The first value returned from this function will tell you the data type of the column

```{r data_cleaning_2, echo = TRUE}
is(consdata$meter_reading)

is(consdata$actual_estimate)

```


## Data cleaning


- If a column does not have the correct type, we can easily coerce the values into the type that we want
- The exact method is different depending on what you are converting from and to
- Generally speaking however, the method for converting a column type is:

```{r data_cleaning_3, eval = FALSE, echo = TRUE}
dataframe$column <- as.xxxxx(dataframe$column)
```


## Data cleaning - exercise


- Convert the meter reading column into a character, check that it's been converted, and then convert it back to numeric

```{r data_cleaning_exercise, eval = TRUE, echo = TRUE}

consdata$meter_reading <- as.character(consdata$meter_reading)

is.character(consdata$meter_reading)

consdata$meter_reading <- as.numeric(consdata$meter_reading)
```


## Data cleaning

- This method works well for:
    - Numeric/integer to character
    - Character to numeric/integer
    - Integer to numeric
    - Numeric to integer
    - Character to factor
    - Factor to character
    - Numeric to factor
- For factor to numeric, there's an extra step:
    - Before the factors levels can be converted, they need to be converted to characters first:

```{r data_cleaning_5, echo = TRUE, eval = FALSE}

dataframe$column <- as.numeric(as.character(dataframe$column))

```

## Data cleaning - dates


- Dates in R can be tricky
    - R will not import date values in as dates unless you specify that it should
        - But RStudio's "Import Dataset" feature can be pretty handy here...
    - If you don't, R will import them as characters (which means they'll be converted to factors unless you specify `stringsAsFactors = FALSE`)
- To convert a character to a date, use the `as.Date()` function...

## Data cleaning - dates (example)


```{r data_cleaning_dates, echo = TRUE}
datetest <- "12/12/2018"
datetest <- as.Date(datetest, format = "%d/%m/%Y")
is(datetest)
```

- To convert from a factor to a date, first convert to a character...

## Data cleaning - dates (exercise)


- Our `consdata$settlement_date` column is currently a factor, convert it to date
- Remeber to convert the column to character first!

```{r data_cleaning_dates_exercise, echo = TRUE, eval = TRUE}
consdata$settlement_date <- as.character(consdata$settlement_date)
consdata$settlement_date <- as.Date(consdata$settlement_date, format = "%d/%m/%Y")
```

```{r data_cleaning_dates_exercise_alt, echo = TRUE, eval = FALSE}
consdata$settlement_date <- as.Date(as.character(consdata$settlement_date), format = "%d/%m/%Y")
```


## Data cleaning - dates 


- Dates can also come in numeric form, calculated as the number of days from a particular origin
- For example, a numeric value of 1, with an origin of 12/12/2018 would correspond to a date value of 13/12/2018
- If your date values are in numeric format, you need to specify the origin in the `as.Date()` function...

## Data cleaning - dates (example)


```{r data_cleaning_dateS_numeric, echo = TRUE}
datetest <- 17940
datetest <- as.Date(datetest, origin = as.Date("01/01/1970", format = "%d/%m/%Y"))
datetest
```


## Data cleaning - dates


- With dates, always specify the format (format codes can be found online and are included in your help sheet)
- There's no `is.Date()` function in base R
- So to check whether a value is a date, use `is()`


## Data cleaning - conclusion


- To find out the type of a column, use the `is()` function
- Otherwise, you can (usually) test if a column is a specific type via the is.xxxxx functions
- Converting between datatypes (except from numeric -> factor) is easy with the as.xxxxx functions
- When converting numbers to factors, convert them to characters first
- When converting from characters or numeric to dates, `as.Date()` requires "format" or "origin" parameters respectively 

## Summary statistics


- Before doing any in-depth analysis, it's always a good idea to get some descriptive statistics from your data
- This includes the mean, the median, the standard deviation, and the interquartile range, but the statistics you use will depend on your data
- Getting these values for each column is easy using the built-in functions R provides:

```{r summary_statistics_1, echo = TRUE, eval = FALSE}
mean()
median()
sd()
quantile()
```

## Summary statistics - exercise


- Find the mean, median, standard deviation, and quantiles for our meter reading column

```{r summary_statistics_exercise, echo = TRUE}
mean(consdata$meter_reading)
median(consdata$meter_reading)
sd(consdata$meter_reading)
quantile(consdata$meter_reading)
```

## Summary statistics


- More often than not however, you'll want summary statistics for more than one column, or maybe broken down by group
- R includes a function that will give you summary statistics for each column (the `summary()` function):

```{r summary_statistics_3, echo = TRUE}
summary(consdata)
```

## Summary statistics by group



- Summary statistics by group are a little bit more complicated as they require as to `apply` the function twice, once for each group
- To do that, we use the tapply function, say that we want to use the consdata dataset, split it by group, and then use the summary function
- Note: You'll likely get some error messages if one of your columns isn't numeric, but you can ignore them

```{r summary_statistics_by_group_1_hidden, eval = FALSE}
tapply(consdata, consdata$actual_estimate, summary)
```

## Summary statistics by group - exercise

- Produce summary statistics by Settlement Date

## Summary statistics by group - answer


```{r summary_stats_answer_2, eval = FALSE}
tapply(consdata, consdata$actual_estimate, summary)
```



## Summary statistics by group


```{r summary_statistics_by_group_2, eval = TRUE, echo = FALSE}
tapply(consdata, consdata$actual_estimate, summary)
```


## Summary statistics - conclusion


- Producing summary statistics for columns in a dataframe can be done through the `mean()`, `median()`, `sd()`, and `quartile()` functions
- Producing summary statistics for multiple columns can be done with the `summary()` function
- Producing summary statistics by group requires us to `apply` the `summary()` function to each group


## Plotting


- After calculating your summary statistics, it can be useful to visualise the data to better understand any trends or differences
- For example, we may want to see if there's a difference between the meter reading values for estimates vs. actuals
- We could use a plot to visualise that difference
- There are two good ways to create plots
    - The first uses R's built-in plotting functions
    - The second uses a package called "ggplot2"

## Plotting


- R's main plotting function is `plot()`
- This function takes the data you want to visualise as it's only required argument, with optional arguments to specify what kind of plot you want
- If you don't specify what kind of plot you want, `plot()` tries to guess the most appropriate type of plot for your data, and creates it

## Plotting - example


- First off, let's plot the meter reading values of estimates and actuals to see if there's a difference:

```{r plotting_example_1, echo = TRUE, eval = FALSE}
plot(x = consdata$actual_estimate, y = consdata$meter_reading)
```

## Plotting - example

```{r plotting_example_1_hidden, echo = FALSE, fig.align = "center"}
plot(x = consdata$actual_estimate, y = consdata$meter_reading)
```

## Plotting - example

- As you can see, we've specified our x and y axis, but not what type of plot we want
- But the `plot()` function has guessed that we probably want a boxplot
- Note: you can also force R to create a boxplot using the `boxplot()` function

## Plotting - example


- Next, we might want to see if there's a correlation between the meter reading and the temperature
- Again, we can use the plot function, specify our x and y axis, and R will guess what the best plot is

```{r plotting_example_2, echo = TRUE, eval = FALSE}
plot(x = consdata$meter_reading, y = consdata$avg_temperature_c)
```

## Plotting - example

```{r plotting_example_2_hidden, echo = FALSE, fig.align = "center"}
plot(x = consdata$meter_reading,y = consdata$avg_temperature_c)
```


- R has created a scatter plot by default, but we can change the type if we wish using the option "type" argument
- See your help sheet for the different types

## Plotting - exercise


- Create a plot of meter readings against Settlement Periods...


## Plotting - answer


```{r plotting_exercise, eval = TRUE, echo = TRUE}
plot(x = consdata$settlement_period, y = consdata$meter_reading)
```


## Histograms - example


- One of the best features of the plotting system in R is how easy it is to make histograms
- You can either use the `plot()` function and specify "h" as the type, or we can use the `hist()` function and provide one variable to produce a simple histogram...

```{r histograms, echo = TRUE, eval = FALSE}
hist(consdata$meter_reading)
```

## Histograms - example


```{r histograms_hidden, echo = FALSE, eval = TRUE, fig.align = "center"}
hist(consdata$meter_reading)
```


## Customizing your graphs


- To make your graph easier to understand, you may want to...
    - Change the title
    - Change the axis labels
    - Change the points
    - Change the size of the bins for our histogram
- Note: These are a few of the customization options, but there are many, many more

## Customizing your graphs

- Change the title
    - To change the title, all we need to do is specify a "main" parameter in our plot function...
    
```{r customizing_graphs_title, eval = FALSE}
plot(consdata$meter_reading, consdata$avg_temperature_c,
     main = "Correlation between temperature and consumption")
```

- Change the axis labels
    - To change the labels on the axes, we use the "xlab"/"ylab"" parameters...

```{r customizing_graphs_axis, eval = FALSE}
plot(consdata$meter_reading, consdata$avg_temperature_c,
     main = "Correlation between temperature and consumption",
     xlab = "Meter reading (KwH)",
     ylab = "Temperature (degrees Celsius)")
``` 


## Customizing your graphs

- Changing the graph points
    - To change the points, we use the "pch" paremeter, and specify a value between 0 and 25...

```{r customizing_graphs_points, eval = FALSE}
plot(consdata$meter_reading, consdata$avg_temperature_c,
     main = "Correlation between temperature and consumption",
     xlab = "Meter reading (KwH)",
     ylab = "Temperature (degress Celsius)",
     pch = 19)
``` 

- Putting those all together...

## Customizing your graphs


```{r customizing_graphs_total, echo = FALSE, eval = TRUE, fig.align = "center"}
plot(consdata$meter_reading, consdata$avg_temperature_c,
     main = "Correlation between temperature and consumption",
     xlab = "Meter reading (KwH)",
     ylab = "Temperature (degrees Celsius)",
     pch = 19)
``` 

## Customizing your graphs (histograms)


- In addition to the previous customization options, for histograms, we can change the size of the bins
    - To do this, we specify the "breaks" parameter in our `hist()` function
    - This splits up out our data into x number of bins of equal size
    
```{r customizing_graphs_hist, eval = FALSE}
hist(consdata$meter_reading, breaks = 30)
```

## Customizing your graphs (histograms)


```{r customizing_graphs_hist_hidden, echo = FALSE, eval = TRUE, out.width=c("50%", "50%"), fig.show='hold'}
hist(consdata$meter_reading, breaks = 30)
hist(consdata$meter_reading)
```

## Plotting - final exercise

- Create a plot of your choice, and change the title and axis labels.

## Plotting - conclusion

- In short, R has lots of in-built tools to make quick, simple graphs and plots
- Most types of graph only require a few input parameters, but there's lots of customization options
- In a later module, we'll look at a package called ggplot2, which we'll use to create more complex and professional graphics

## Conclusion


- Installing packages
    - `install.packages()`, `library()`
- Loading data
    - `read.csv()`/`read.xlsx()`
- Cleaning data
    - Data type checks
    - Data type conversion
        - Look out for dates and factors!
- Plotting
    - `plot()`/`hist()`
- Customization
    - "main", "xlab", "ylab", "pch", "breaks"
- Next time...
    - Creating functions
    - For loops
    - If else statements
